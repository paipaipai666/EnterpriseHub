# EnterpriseHub - Go 企业级微服务项目

## 项目简介

EnterpriseHub 是一个基于 Go 语言构建的企业级微服务架构实践项目，完整实现了用户管理、认证授权、订单处理、支付模拟、异步通知等核心业务场景。项目采用 **API Gateway + 微服务** 的经典架构，通过 gRPC 实现高效的服务间通信，使用 RabbitMQ 实现异步解耦，具备清晰的服务边界和可扩展的企业级工程结构。

本项目严格遵循 Go 语言最佳实践，采用分层架构设计，将 API 层、业务逻辑层、数据访问层清晰分离。每一层都有明确的职责定义，通过接口实现解耦，便于单元测试和后续扩展。项目的工程化程度高，目录结构规范，依赖管理清晰，适合作为 Go 微服务学习的标杆项目，也适合作为实习、面试展示的实战案例。

---

## 技术栈

### 核心语言与框架

| 分类 | 技术选型 | 说明 |
|------|----------|------|
| 开发语言 | Go 1.22+ | 高性能、编译型语言，适合微服务场景 |
| Web 框架 | Gin | 轻量级 HTTP 框架，性能优异中间件生态丰富 |
| RPC 框架 | gRPC | Google 开源的高性能 RPC 框架，基于 Protobuf |
| ORM 框架 | GORM | Go 语言最流行的 ORM 库，支持自动迁移 |

### 数据存储与缓存

| 分类 | 技术选型 | 说明 |
|------|----------|------|
| 关系型数据库 | MySQL 8 | 企业级数据库，一服务一库避免耦合 |
| 缓存数据库 | Redis | 用于 JWT Token 缓存、Session 管理 |
| 消息队列 | RabbitMQ | 实现服务间异步通信、事件驱动架构 |

### 基础设施与运维

| 分类 | 技术选型 | 说明 |
|------|----------|------|
| 日志框架 | Zap | Uber 开源的高性能结构化日志库 |
| 认证授权 | JWT (golang-jwt) | 无状态 Token 认证方案 |
| 配置管理 | godotenv | 环境变量加载管理 |
| 容器化 | Docker | 服务容器化部署 |

### 通信协议

| 通信类型 | 协议 | 应用场景 |
|----------|------|----------|
| 外部通信 | HTTP/JSON | 客户端与网关交互 |
| 内部通信 | gRPC | 服务间高效通信 |
| 异步通信 | AMQP (RabbitMQ) | 事件驱动、异步解耦 |

---

## 系统架构

### 整体架构图

```
                              ┌─────────────────┐
                              │    Client       │
                              │  (Web/App)      │
                              └────────┬────────┘
                                       │
                              ┌────────▼────────┐
                              │  Gateway        │ :8080
                              │  - JWT 鉴权      │
                              │  - 路由转发      │
                              │  - 限流(可扩展)  │
                              └────────┬────────┘
                                       │
              ┌────────────────────────┼────────────────────────┐
              │                        │                        │
     ┌────────▼────────┐      ┌────────▼────────┐      ┌────────▼────────┐
     │  User Service   │      │  Auth Service   │      │  Order Service  │
     │  HTTP :8000     │      │  HTTP :9000      │      │  HTTP :10000    │
     │  gRPC  :8001    │      │                  │      │                  │
     └────────┬────────┘      └────────┬────────┘      └────────┬────────┘
              │                        │                        │
              │              ┌─────────▼─────────┐               │
              │              │                   │               │
              │     ┌────────▼────────┐          │               │
              │     │  User Service   │◄──────────┘               │
              │     │  gRPC :8001     │                          │
              │     └─────────────────┘                          │
              │                                                   │
              │              ┌───────────────────────────────────┘
              │              │
     ┌────────▼────────┐     │
     │  Payment        │     │
     │  Service        │     │
     │  gRPC :11001    │     │
     └─────────────────┘     │
                              │  RabbitMQ
                              │  (异步消息)
                              ▼
                    ┌─────────────────┐
                    │  Notify Service │
                    │  - 消息消费     │
                    │  - 通知处理     │
                    └─────────────────┘
```

### 服务职责说明

| 服务名称 | 端口 | 通信协议 | 核心职责 |
|----------|------|----------|----------|
| gateway-service | 8080 | HTTP | 统一入口、路由转发、JWT 鉴权、请求分发 |
| user-service | 8000/8001 | HTTP + gRPC | 用户注册、信息查询、用户管理 |
| auth-service | 9000 | HTTP | 登录认证、JWT Token 生成与校验、Token 缓存 |
| order-service | 10000 | HTTP | 订单创建、订单查询、订单支付、状态流转 |
| payment-service | 11001 | gRPC | 支付处理、支付状态管理、支付回调 |
| notify-service | - | RabbitMQ | 消息消费、异步通知、事件处理 |

### 服务间调用关系

整个系统的业务调用链路遵循清晰的层次结构：客户端请求首先到达 Gateway，Gateway 完成 JWT 鉴权后将请求路由到对应的业务服务。Auth Service 负责用户认证，生成 JWT Token 并缓存到 Redis 实现 Token 管理。User Service 存储用户数据，被 Auth Service 通过 gRPC 调用以校验用户凭证。

Order Service 是业务核心，负责订单全生命周期管理。当用户下单时，Order Service 调用 Payment Service 的 gRPC 接口完成支付处理，支付成功后发布消息到 RabbitMQ。Notify Service 作为消费者监听消息队列，处理订单创建、支付成功等事件的异步通知逻辑。这种架构设计实现了服务间的高效通信与业务解耦。

---

## 项目亮点

### 架构设计亮点

本项目在架构设计上充分考虑了微服务的核心理念，实现了多个重要的工程实践。首先是**服务拆分与边界划分**，每个服务都有明确的业务职责，遵循单一职责原则，避免服务间过度耦合。User Service 专注用户数据管理，Auth Service 专注认证授权，Order Service 专注订单业务，Payment Service 专注支付处理，Notify Service 专注消息消费，各服务各司其职又协同工作。

其次是**双协议通信架构**，对外采用 HTTP/JSON 提供 RESTful 接口，方便前端和第三方调用；对内采用 gRPC 实现高效的服务间通信。gRPC 基于 Protobuf 定义接口契约，具有强类型、自动生成代码、支持多语言等优势，相比 HTTP 更加高效，特别适合高并发场景下的服务间调用。

第三是**事件驱动异步解耦**，通过 RabbitMQ 实现服务间的异步通信。当订单创建或支付成功后，系统发布相应事件到消息队列，Notify Service 异步消费消息处理通知逻辑。这种设计避免了同步调用带来的性能瓶颈和级联失败风险，提高了系统的可靠性和可扩展性。

### 工程实践亮点

在工程实践层面，本项目展现了高度规范化的开发标准。**分层架构设计**将系统划分为 API 层、Service 层、Repository 层、Domain 层，每一层都有明确的职责：API 层负责 HTTP 请求处理和参数校验，Service 层承载核心业务逻辑，Repository 层封装数据访问操作，Domain 层定义领域模型和业务规则。这种分层设计提高了代码的可维护性和可测试性。

**依赖注入与面向接口编程**是本项目的另一大亮点。所有 Service 依赖 Repository 接口而非具体实现，所有 Controller 依赖 Service 接口，通过构造函数注入依赖。这种设计使得各层之间解耦，可以轻松替换实现（如用 Mock 替代真实数据库进行单元测试），也便于后续功能扩展。

**结构化日志与可观测性**也是本项目的重要实践。引入 Zap 日志框架替代传统的 fmt.Println，所有日志采用 JSON 格式输出，包含时间戳、日志级别、调用位置、错误堆栈等丰富信息。日志文件按服务名称分开存储，支持日志轮转和压缩，便于问题排查和系统监控。

### 业务场景亮点

在业务实现上，本项目覆盖了企业级应用的典型场景。**JWT Token 管理**实现了完整的认证授权流程，包括 Token 生成、Token 缓存、Token 验证、Token 注销等功能。Auth Service 将登录后的 Token 缓存到 Redis，实现 Token 的集中管理和主动失效机制。

**订单状态机**是本项目的业务核心，订单领域模型定义了完整的状态流转规则：Created → Paid → Completed，Created 状态可以 Cancel，状态流转均有业务校验逻辑，防止非法状态变更。这种设计确保了业务规则的一致性和可维护性。

**支付流程设计**模拟了真实的支付场景，支持多种支付方式，包含支付创建、支付处理、支付回调、支付状态查询等完整流程。Payment Service 独立部署，通过 gRPC 为 Order Service 提供支付能力，体现了微服务按能力拆分的思想。

---

## 快速开始

### 环境要求

确保开发环境已安装以下工具：Go 1.22+、MySQL 8.0+、Redis 6.0+、RabbitMQ 3.8+、Docker（可选）。

### 启动步骤

第一步，启动基础中间件。如果使用 Docker，可以直接运行 docker-compose up -d 启动 MySQL、Redis、RabbitMQ。也可以本地安装各中间件服务。

第二步，配置环境变量。每个服务目录下都有 .env 文件，需要根据本地环境修改数据库连接地址、Redis 地址、RabbitMQ 地址等配置。

第三步，启动各服务。建议按以下顺序启动：先启动 user-service（提供用户数据），再启动 auth-service（提供认证），然后启动 payment-service（提供支付能力），接着启动 order-service（订单业务），再启动 notify-service（消息消费），最后启动 gateway-service（统一入口）。

第四步，验证服务是否正常。可以通过 curl 或 Postman 测试各接口，查看日志确认服务启动正常。

### 常用命令

```bash
# 启动单个服务
cd user-service && go run cmd/main.go

# 运行测试
cd user-service && go test ./...

# 代码格式化
gofmt -w .

# 代码检查
go vet ./...
```

---

## 目录结构

```
enterprisehub/
├── cmd/                          # 各服务入口文件
├── internal/                     # 内部包
│   ├── api/                      # HTTP Handler / Controller
│   ├── service/                  # 业务逻辑层
│   ├── repository/               # 数据访问层
│   ├── domain/                   # 领域模型
│   ├── model/                    # 数据模型
│   ├── handler/                  # gRPC Handler
│   ├── client/                   # gRPC 客户端封装
│   ├── middleware/               # 中间件
│   ├── config/                   # 配置
│   └── mq/                       # 消息队列相关
├── initializers/                 # 初始化组件（DB、Redis、日志）
├── migration/                    # 数据库迁移脚本
├── proto/                        # gRPC 协议定义文件
├── .env                          # 环境变量配置
├── go.mod                        # Go 依赖管理
└── README.md                     # 项目说明文档
```

---

## 扩展方向

本项目具备良好的扩展性，后续可以从以下方向持续演进：引入 Kubernetes 进行容器编排和服务治理，实现自动扩缩容、滚动升级、服务发现等能力；接入 Prometheus + Grafana 构建监控体系，监控服务健康度、接口性能、错误率等关键指标；引入 OpenTelemetry 实现全链路追踪，跟踪请求在多个服务间的调用链路，快速定位性能瓶颈和故障点；增加 CI/CD 自动化部署流程，实现代码提交后自动构建、测试、部署；集成分布式 ID 生成器（如 Snowflake 算法）替代 UUID，提升数据库索引效率；引入多级缓存架构（本地缓存 + Redis 缓存）提升查询性能。

---

## 许可证

本项目仅供学习和参考使用。

---

## 作者

EnterpriseHub - 企业级 Go 微服务实践项目
